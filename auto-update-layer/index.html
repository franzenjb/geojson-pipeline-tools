<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Update Layer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Georgia', 'Times New Roman', serif; background: #ffffff; color: #333; line-height: 1.6; }
        .header { background: #C8102E; color: white; padding: 30px 20px; text-align: center; border-bottom: 3px solid #8B0000; }
        .back-link { display: inline-block; color: white; text-decoration: none; font-size: 14px; margin-bottom: 15px; opacity: 0.9; transition: opacity 0.2s; }
        .back-link:hover { opacity: 1; text-decoration: underline; }
        .header h1 { font-size: 28px; margin-bottom: 10px; }
        .header p { font-size: 14px; opacity: 0.9; }
        .container { max-width: 1200px; margin: 0 auto; padding: 30px 20px; }
        .section { background: white; border-radius: 4px; padding: 25px; margin-bottom: 25px; border: 1px solid #e0e0e0; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
        .section h3 { color: #333; margin-bottom: 15px; font-size: 18px; font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
        .input-group { margin-bottom: 20px; }
        .input-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #555; }
        .input-group input, .input-group select, .input-group textarea { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; font-family: inherit; }
        .input-group input:focus, .input-group select:focus, .input-group textarea:focus { outline: none; border-color: #C8102E; box-shadow: 0 0 0 2px rgba(200,16,46,0.1); }
        .help-text { font-size: 12px; color: #666; margin-top: 5px; }
        .info-button { background: #C8102E; color: white; border: none; padding: 12px 24px; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background 0.2s; width: 100%; }
        .info-button:hover { background: #8B0000; }
        .info-button:disabled { background: #ccc; cursor: not-allowed; }
        .info-button.success { background: #10b981; }
        .info-button.secondary { background: #003f87; }
        .reset-btn { background: #C8102E; color: white; border: none; padding: 6px 12px; font-size: 12px; border-radius: 4px; cursor: pointer; }
        .options-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .status-message { padding: 12px 15px; border-radius: 6px; margin-bottom: 15px; display: none; }
        .status-message.info { background: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; display: block; }
        .status-message.success { background: #d1fae5; color: #065f46; border: 1px solid #6ee7b7; display: block; }
        .status-message.error { background: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; display: block; }
        .status-message.warning { background: #fef3c7; color: #92400e; border: 1px solid #fcd34d; display: block; }
        .hidden { display: none !important; }
        .file-drop { border: 2px dashed #ddd; border-radius: 8px; padding: 40px 20px; text-align: center; cursor: pointer; transition: all 0.2s; background: #fafafa; }
        .file-drop:hover, .file-drop.dragover { border-color: #C8102E; background: #fef7f7; }
        .file-drop .icon { font-size: 48px; margin-bottom: 10px; }
        .file-drop p { color: #666; margin: 5px 0; }
        .file-drop .formats { font-size: 12px; color: #999; }
        .operation-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .operation-card { border: 2px solid #e0e0e0; border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .operation-card:hover { border-color: #C8102E; background: #fef7f7; }
        .operation-card.selected { border-color: #C8102E; background: #fef7f7; box-shadow: 0 0 0 3px rgba(200,16,46,0.1); }
        .operation-card .icon { font-size: 32px; margin-bottom: 10px; }
        .operation-card .title { font-weight: 700; color: #333; margin-bottom: 5px; }
        .operation-card .desc { font-size: 12px; color: #666; }
        .progress-bar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin: 15px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #C8102E, #ff4d6d); transition: width 0.3s; }
        .log-container { background: #1e293b; border-radius: 8px; padding: 15px; margin-top: 20px; max-height: 300px; overflow-y: auto; }
        .log-entry { font-family: 'Courier New', monospace; font-size: 12px; padding: 4px 0; border-bottom: 1px solid #334155; }
        .log-entry.info { color: #93c5fd; }
        .log-entry.success { color: #6ee7b7; }
        .log-entry.error { color: #fca5a5; }
        .log-entry.warning { color: #fcd34d; }
        .field-mapping { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin-top: 15px; }
        .mapping-row { display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center; padding: 8px 0; border-bottom: 1px solid #e2e8f0; }
        .mapping-row:last-child { border-bottom: none; }
        .mapping-row span { text-align: center; color: #666; }
        .mapping-row select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-top: 15px; }
        .stat-card { background: #f8fafc; border-radius: 8px; padding: 15px; text-align: center; }
        .stat-card .value { font-size: 24px; font-weight: 700; color: #C8102E; }
        .stat-card .label { font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <a href="../index.html" class="back-link">‚Üê Back to All Tools</a>
        <h1>ü§ñ Auto-Update Layer</h1>
        <p>Automatically update ArcGIS Feature Layers with new data</p>
    </div>
    <div class="container">
        <div id="statusMessage" class="status-message"></div>

        <div class="section">
            <h3>üîê Authentication <button onclick="resetTool()" class="reset-btn">Reset</button></h3>
            <div class="input-group">
                <label>ArcGIS Token:</label>
                <input type="password" id="token" placeholder="Enter your ArcGIS access token">
                <p class="help-text">Generate a token from the <a href="../oauth-tokens/index.html" target="_blank">OAuth Tokens tool</a> or your ArcGIS portal</p>
            </div>
        </div>

        <div class="section">
            <h3>üéØ Target Feature Layer</h3>
            <div class="input-group">
                <label>Feature Service URL:</label>
                <input type="text" id="serviceUrl" placeholder="https://services.arcgis.com/.../FeatureServer/0">
                <p class="help-text">Enter the full URL to the feature layer (including layer number)</p>
            </div>
            <button onclick="validateService()" class="info-button secondary">üîç Validate Service</button>

            <div id="serviceInfo" class="hidden" style="margin-top: 20px;">
                <h4 style="margin-bottom: 10px;">Service Information</h4>
                <div class="stats-grid" id="serviceStats"></div>
            </div>
        </div>

        <div class="section">
            <h3>üìÇ Source Data</h3>
            <div class="file-drop" id="fileDrop" onclick="document.getElementById('fileInput').click()">
                <div class="icon">üìÑ</div>
                <p><strong>Click to upload or drag & drop</strong></p>
                <p class="formats">Supports: CSV, GeoJSON, JSON</p>
                <input type="file" id="fileInput" accept=".csv,.geojson,.json" style="display: none;" onchange="handleFileSelect(event)">
            </div>
            <div id="fileInfo" class="hidden" style="margin-top: 15px;">
                <div class="stats-grid" id="fileStats"></div>
            </div>
        </div>

        <div class="section hidden" id="operationSection">
            <h3>‚öôÔ∏è Update Operation</h3>
            <div class="operation-cards">
                <div class="operation-card selected" onclick="selectOperation('append')" data-op="append">
                    <div class="icon">‚ûï</div>
                    <div class="title">Append</div>
                    <div class="desc">Add new features without modifying existing ones</div>
                </div>
                <div class="operation-card" onclick="selectOperation('overwrite')" data-op="overwrite">
                    <div class="icon">üîÑ</div>
                    <div class="title">Overwrite</div>
                    <div class="desc">Delete all existing features and add new ones</div>
                </div>
                <div class="operation-card" onclick="selectOperation('update')" data-op="update">
                    <div class="icon">‚úèÔ∏è</div>
                    <div class="title">Update</div>
                    <div class="desc">Update existing features based on unique ID field</div>
                </div>
                <div class="operation-card" onclick="selectOperation('upsert')" data-op="upsert">
                    <div class="icon">üîÄ</div>
                    <div class="title">Upsert</div>
                    <div class="desc">Update existing or insert new features</div>
                </div>
            </div>

            <div id="updateOptions" class="hidden">
                <div class="input-group">
                    <label>Unique ID Field (for matching):</label>
                    <select id="uniqueIdField"></select>
                    <p class="help-text">Field used to match source records to existing features</p>
                </div>
            </div>
        </div>

        <div class="section hidden" id="mappingSection">
            <h3>üóÇÔ∏è Field Mapping</h3>
            <p style="margin-bottom: 15px; color: #666;">Map source data fields to target layer fields</p>
            <div class="field-mapping" id="fieldMapping"></div>
        </div>

        <div class="section hidden" id="executeSection">
            <h3>üöÄ Execute Update</h3>
            <div class="options-grid">
                <div class="input-group" style="margin-bottom: 0;">
                    <label>Batch Size:</label>
                    <select id="batchSize">
                        <option value="100">100 features</option>
                        <option value="250" selected>250 features</option>
                        <option value="500">500 features</option>
                        <option value="1000">1000 features</option>
                    </select>
                </div>
                <div class="input-group" style="margin-bottom: 0;">
                    <label>Rollback on Error:</label>
                    <select id="rollbackOnError">
                        <option value="true">Yes - Rollback all changes</option>
                        <option value="false">No - Keep successful changes</option>
                    </select>
                </div>
            </div>
            <button onclick="executeUpdate()" id="executeBtn" class="info-button">üöÄ Execute Update</button>

            <div id="progressContainer" class="hidden">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <p id="progressText" style="text-align: center; font-size: 14px; color: #666;">Preparing...</p>
            </div>

            <div class="log-container hidden" id="logContainer">
                <div id="logEntries"></div>
            </div>
        </div>

        <div class="section hidden" id="resultsSection">
            <h3>‚úÖ Update Complete</h3>
            <div class="stats-grid" id="resultStats"></div>
        </div>

        <div class="section" style="background: #fef3c7; border: 1px solid #fcd34d;">
            <h3 style="color: #92400e;">‚ö†Ô∏è Important Notes</h3>
            <ul style="margin: 10px 0; padding-left: 20px; font-size: 14px; color: #78350f;">
                <li>Always backup your data before performing updates</li>
                <li>Overwrite operation will DELETE all existing features first</li>
                <li>Your token must have edit permissions on the target layer</li>
                <li>Large datasets are processed in batches to avoid timeouts</li>
                <li>Field types must be compatible between source and target</li>
            </ul>
        </div>
    </div>

    <script>
        let serviceFields = [];
        let sourceData = [];
        let sourceFields = [];
        let selectedOperation = 'append';
        let serviceName = '';
        let serviceType = '';

        function showStatus(message, type = 'info') {
            const el = document.getElementById('statusMessage');
            el.textContent = message;
            el.className = 'status-message ' + type;
        }

        function log(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const entries = document.getElementById('logEntries');
            container.classList.remove('hidden');

            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entries.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }

        function resetTool() {
            document.getElementById('token').value = '';
            document.getElementById('serviceUrl').value = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('serviceInfo').classList.add('hidden');
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('operationSection').classList.add('hidden');
            document.getElementById('mappingSection').classList.add('hidden');
            document.getElementById('executeSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('progressContainer').classList.add('hidden');
            document.getElementById('logContainer').classList.add('hidden');
            document.getElementById('logEntries').innerHTML = '';
            document.getElementById('statusMessage').className = 'status-message';
            sourceData = [];
            sourceFields = [];
            serviceFields = [];

            // Reset file drop area
            const fileDrop = document.getElementById('fileDrop');
            fileDrop.innerHTML = `
                <div class="icon">üìÑ</div>
                <p><strong>Click to upload or drag & drop</strong></p>
                <p class="formats">Supports: CSV, GeoJSON, JSON</p>
                <input type="file" id="fileInput" accept=".csv,.geojson,.json" style="display: none;" onchange="handleFileSelect(event)">
            `;
        }

        async function validateService() {
            const url = document.getElementById('serviceUrl').value.trim();
            const token = document.getElementById('token').value.trim();

            if (!url) {
                showStatus('Please enter a service URL', 'error');
                return;
            }

            showStatus('Validating service...', 'info');

            try {
                const params = new URLSearchParams({ f: 'json' });
                if (token) params.append('token', token);

                const response = await fetch(`${url}?${params}`);
                const data = await response.json();

                if (data.error) {
                    showStatus(`Service error: ${data.error.message}`, 'error');
                    return;
                }

                serviceName = data.name || 'Unknown';
                serviceType = data.type || 'Feature Layer';
                serviceFields = data.fields || [];

                // Check if editable
                const capabilities = data.capabilities || '';
                const canEdit = capabilities.toLowerCase().includes('editing') ||
                               capabilities.toLowerCase().includes('create') ||
                               capabilities.toLowerCase().includes('update');

                const statsHtml = `
                    <div class="stat-card">
                        <div class="value">${serviceName}</div>
                        <div class="label">Layer Name</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${serviceFields.length}</div>
                        <div class="label">Fields</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${data.geometryType || 'N/A'}</div>
                        <div class="label">Geometry</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" style="color: ${canEdit ? '#10b981' : '#ef4444'}">${canEdit ? 'Yes' : 'No'}</div>
                        <div class="label">Editable</div>
                    </div>
                `;

                document.getElementById('serviceStats').innerHTML = statsHtml;
                document.getElementById('serviceInfo').classList.remove('hidden');

                if (!canEdit) {
                    showStatus('Warning: This layer may not support editing. Check your permissions.', 'warning');
                } else {
                    showStatus('Service validated successfully!', 'success');
                }

                checkReadyForMapping();

            } catch (error) {
                showStatus(`Error validating service: ${error.message}`, 'error');
            }
        }

        // File handling
        const fileDrop = document.getElementById('fileDrop');

        fileDrop.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDrop.classList.add('dragover');
        });

        fileDrop.addEventListener('dragleave', () => {
            fileDrop.classList.remove('dragover');
        });

        fileDrop.addEventListener('drop', (e) => {
            e.preventDefault();
            fileDrop.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) processFile(file);
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) processFile(file);
        }

        async function processFile(file) {
            showStatus('Processing file...', 'info');

            const reader = new FileReader();
            reader.onload = async (e) => {
                const content = e.target.result;
                const fileName = file.name.toLowerCase();

                try {
                    if (fileName.endsWith('.csv')) {
                        parseCSV(content);
                    } else if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                        parseJSON(content);
                    } else {
                        showStatus('Unsupported file format', 'error');
                        return;
                    }

                    // Update file drop area
                    fileDrop.innerHTML = `
                        <div class="icon">‚úÖ</div>
                        <p><strong>${file.name}</strong></p>
                        <p class="formats">${sourceData.length} records loaded</p>
                        <input type="file" id="fileInput" accept=".csv,.geojson,.json" style="display: none;" onchange="handleFileSelect(event)">
                    `;

                    // Show file stats
                    const statsHtml = `
                        <div class="stat-card">
                            <div class="value">${sourceData.length}</div>
                            <div class="label">Records</div>
                        </div>
                        <div class="stat-card">
                            <div class="value">${sourceFields.length}</div>
                            <div class="label">Fields</div>
                        </div>
                        <div class="stat-card">
                            <div class="value">${(file.size / 1024).toFixed(1)} KB</div>
                            <div class="label">File Size</div>
                        </div>
                        <div class="stat-card">
                            <div class="value">${fileName.split('.').pop().toUpperCase()}</div>
                            <div class="label">Format</div>
                        </div>
                    `;
                    document.getElementById('fileStats').innerHTML = statsHtml;
                    document.getElementById('fileInfo').classList.remove('hidden');

                    showStatus(`Loaded ${sourceData.length} records from ${file.name}`, 'success');
                    checkReadyForMapping();

                } catch (error) {
                    showStatus(`Error parsing file: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }

        function parseCSV(content) {
            const lines = content.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
            sourceFields = headers;
            sourceData = [];

            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length === headers.length) {
                    const record = {};
                    headers.forEach((h, idx) => {
                        record[h] = values[idx];
                    });
                    sourceData.push(record);
                }
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function parseJSON(content) {
            const data = JSON.parse(content);

            if (data.type === 'FeatureCollection' && data.features) {
                // GeoJSON
                sourceData = data.features.map(f => ({
                    ...f.properties,
                    _geometry: f.geometry
                }));
                if (sourceData.length > 0) {
                    sourceFields = Object.keys(sourceData[0]).filter(k => k !== '_geometry');
                }
            } else if (Array.isArray(data)) {
                // JSON array
                sourceData = data;
                if (sourceData.length > 0) {
                    sourceFields = Object.keys(sourceData[0]);
                }
            } else {
                throw new Error('Invalid JSON format');
            }
        }

        function checkReadyForMapping() {
            if (serviceFields.length > 0 && sourceFields.length > 0) {
                document.getElementById('operationSection').classList.remove('hidden');
                buildFieldMapping();
                document.getElementById('mappingSection').classList.remove('hidden');
                document.getElementById('executeSection').classList.remove('hidden');
            }
        }

        function selectOperation(op) {
            selectedOperation = op;
            document.querySelectorAll('.operation-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.op === op);
            });

            // Show/hide update options
            const updateOptions = document.getElementById('updateOptions');
            if (op === 'update' || op === 'upsert') {
                updateOptions.classList.remove('hidden');
                populateUniqueIdField();
            } else {
                updateOptions.classList.add('hidden');
            }
        }

        function populateUniqueIdField() {
            const select = document.getElementById('uniqueIdField');
            select.innerHTML = serviceFields
                .filter(f => f.type === 'esriFieldTypeOID' || f.type === 'esriFieldTypeString' || f.type === 'esriFieldTypeInteger')
                .map(f => `<option value="${f.name}">${f.name} (${f.type.replace('esriFieldType', '')})</option>`)
                .join('');
        }

        function buildFieldMapping() {
            const container = document.getElementById('fieldMapping');
            const editableFields = serviceFields.filter(f =>
                f.editable !== false &&
                f.type !== 'esriFieldTypeOID' &&
                f.type !== 'esriFieldTypeGlobalID'
            );

            let html = '<div class="mapping-row" style="font-weight: 600; background: #e2e8f0; margin: -15px -15px 10px -15px; padding: 15px; border-radius: 8px 8px 0 0;"><div>Source Field</div><span></span><div>Target Field</div></div>';

            editableFields.forEach(targetField => {
                // Try to auto-match
                const matchedSource = sourceFields.find(sf =>
                    sf.toLowerCase() === targetField.name.toLowerCase() ||
                    sf.toLowerCase().replace(/[_\s]/g, '') === targetField.name.toLowerCase().replace(/[_\s]/g, '')
                );

                html += `
                    <div class="mapping-row">
                        <select data-target="${targetField.name}">
                            <option value="">-- Skip --</option>
                            ${sourceFields.map(sf =>
                                `<option value="${sf}" ${sf === matchedSource ? 'selected' : ''}>${sf}</option>`
                            ).join('')}
                        </select>
                        <span>‚Üí</span>
                        <div>${targetField.name} <small style="color:#999">(${targetField.type.replace('esriFieldType', '')})</small></div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function getFieldMappings() {
            const mappings = {};
            document.querySelectorAll('#fieldMapping select').forEach(select => {
                if (select.value) {
                    mappings[select.dataset.target] = select.value;
                }
            });
            return mappings;
        }

        async function executeUpdate() {
            const token = document.getElementById('token').value.trim();
            const url = document.getElementById('serviceUrl').value.trim();

            if (!token) {
                showStatus('Please enter an access token', 'error');
                return;
            }

            if (sourceData.length === 0) {
                showStatus('No source data loaded', 'error');
                return;
            }

            const mappings = getFieldMappings();
            if (Object.keys(mappings).length === 0) {
                showStatus('Please map at least one field', 'error');
                return;
            }

            const batchSize = parseInt(document.getElementById('batchSize').value);
            const rollback = document.getElementById('rollbackOnError').value === 'true';

            // Prepare UI
            document.getElementById('executeBtn').disabled = true;
            document.getElementById('progressContainer').classList.remove('hidden');
            document.getElementById('logEntries').innerHTML = '';
            document.getElementById('resultsSection').classList.add('hidden');

            log(`Starting ${selectedOperation} operation...`, 'info');
            log(`Processing ${sourceData.length} records in batches of ${batchSize}`, 'info');

            let totalAdded = 0;
            let totalUpdated = 0;
            let totalDeleted = 0;
            let totalFailed = 0;

            try {
                // Handle overwrite - delete all first
                if (selectedOperation === 'overwrite') {
                    log('Deleting existing features...', 'warning');
                    const deleteResult = await deleteAllFeatures(url, token);
                    if (deleteResult.success) {
                        totalDeleted = deleteResult.count;
                        log(`Deleted ${totalDeleted} existing features`, 'success');
                    } else {
                        throw new Error('Failed to delete existing features');
                    }
                }

                // Transform source data to features
                const features = sourceData.map(record => {
                    const attributes = {};
                    Object.entries(mappings).forEach(([target, source]) => {
                        attributes[target] = record[source];
                    });

                    const feature = { attributes };

                    // Add geometry if available
                    if (record._geometry) {
                        feature.geometry = record._geometry;
                    }

                    return feature;
                });

                // Process in batches
                const totalBatches = Math.ceil(features.length / batchSize);

                for (let i = 0; i < features.length; i += batchSize) {
                    const batch = features.slice(i, i + batchSize);
                    const batchNum = Math.floor(i / batchSize) + 1;

                    updateProgress((batchNum / totalBatches) * 100, `Processing batch ${batchNum} of ${totalBatches}`);

                    let result;
                    if (selectedOperation === 'update') {
                        result = await updateFeatures(url, token, batch, rollback);
                        totalUpdated += result.updateResults?.filter(r => r.success).length || 0;
                    } else if (selectedOperation === 'upsert') {
                        result = await upsertFeatures(url, token, batch, rollback);
                        totalAdded += result.addResults?.filter(r => r.success).length || 0;
                        totalUpdated += result.updateResults?.filter(r => r.success).length || 0;
                    } else {
                        // append or overwrite (after delete)
                        result = await addFeatures(url, token, batch, rollback);
                        totalAdded += result.addResults?.filter(r => r.success).length || 0;
                    }

                    // Count failures
                    const addFails = result.addResults?.filter(r => !r.success).length || 0;
                    const updateFails = result.updateResults?.filter(r => !r.success).length || 0;
                    totalFailed += addFails + updateFails;

                    if (addFails > 0 || updateFails > 0) {
                        log(`Batch ${batchNum}: ${addFails + updateFails} failures`, 'error');
                    } else {
                        log(`Batch ${batchNum}: Success`, 'success');
                    }

                    // Small delay between batches
                    await new Promise(r => setTimeout(r, 100));
                }

                updateProgress(100, 'Complete!');
                log('Update operation completed!', 'success');

                // Show results
                const resultsHtml = `
                    <div class="stat-card">
                        <div class="value" style="color: #10b981">${totalAdded}</div>
                        <div class="label">Added</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" style="color: #3b82f6">${totalUpdated}</div>
                        <div class="label">Updated</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" style="color: #f59e0b">${totalDeleted}</div>
                        <div class="label">Deleted</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" style="color: ${totalFailed > 0 ? '#ef4444' : '#10b981'}">${totalFailed}</div>
                        <div class="label">Failed</div>
                    </div>
                `;
                document.getElementById('resultStats').innerHTML = resultsHtml;
                document.getElementById('resultsSection').classList.remove('hidden');

                showStatus(`Update complete: ${totalAdded} added, ${totalUpdated} updated, ${totalFailed} failed`,
                    totalFailed > 0 ? 'warning' : 'success');

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                showStatus(`Update failed: ${error.message}`, 'error');
            } finally {
                document.getElementById('executeBtn').disabled = false;
            }
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        async function addFeatures(url, token, features, rollback) {
            const params = new URLSearchParams({
                f: 'json',
                token: token,
                features: JSON.stringify(features),
                rollbackOnFailure: rollback
            });

            const response = await fetch(`${url}/addFeatures`, {
                method: 'POST',
                body: params
            });
            return response.json();
        }

        async function updateFeatures(url, token, features, rollback) {
            const params = new URLSearchParams({
                f: 'json',
                token: token,
                features: JSON.stringify(features),
                rollbackOnFailure: rollback
            });

            const response = await fetch(`${url}/updateFeatures`, {
                method: 'POST',
                body: params
            });
            return response.json();
        }

        async function upsertFeatures(url, token, features, rollback) {
            // Try update first, then add for failures
            const updateResult = await updateFeatures(url, token, features, false);

            // Find features that failed to update (likely don't exist)
            const failedIndices = updateResult.updateResults
                ?.map((r, i) => r.success ? -1 : i)
                .filter(i => i >= 0) || [];

            if (failedIndices.length > 0) {
                const newFeatures = failedIndices.map(i => features[i]);
                const addResult = await addFeatures(url, token, newFeatures, rollback);
                return {
                    updateResults: updateResult.updateResults,
                    addResults: addResult.addResults
                };
            }

            return updateResult;
        }

        async function deleteAllFeatures(url, token) {
            const params = new URLSearchParams({
                f: 'json',
                token: token,
                where: '1=1'
            });

            const response = await fetch(`${url}/deleteFeatures`, {
                method: 'POST',
                body: params
            });
            const result = await response.json();

            return {
                success: !result.error,
                count: result.deleteResults?.filter(r => r.success).length || 0
            };
        }
    </script>
</body>
</html>
